---
title: gotgit-git权威指南
layout: post
author: WenfengShi
category: 技术
tags: [git]
---
qgit, gitg, GitX
cvs2svn gnupg
git grep "工作区文件内容搜索"
.gitconfig 版本库、全局配置、系统级别的配置文件 --> 采用INI格式文件

git status -s
第一列的M --> 版本库中和暂存区的有差别
第二列的M --> 工作区和暂存区的有差别

蒋鑫
[gotgit--Git权威指南](http://gotgit.readthedocs.io/en/latest/)

Git 权威指南

.git/index 记录文件的时间戳，长度等信息

比较时间戳

git checkout . 或 git checkout -- filename 会用暂存区的文件替换工作区的！
git checkout HEAD . 或 git checkout HEAD <file> 会用HEAD指向的master分支中的文件替换工作区和暂存区的文件！
git rm --cached <file> 从暂存区中删除文件而已！
git reset == git reset HEAD  默认是mixed的，所以暂存区的会被重写   soft  mixed   hard
  暂存区中的文件会被master分支指向的目录树所替换，但工作区不受影响

git reset --soft HEAD^ 仅仅是引用退回，工作区和暂存区的文件不变（可方便的进行重新提交，修改提交的内容）
git reset --mixed HEAD^ == git reset HEAD^
git reset --hard HEAD^ 全部退回上一版本，取消所有修改
git reset HEAD filename 或 git reset -- filename 是 git add filename的反向操作！！！ 工作区的内容不做修改！
游标！ --> git reflog 可以查看 master分支指向的变迁

git diff 工作区和暂存区
git diff --cached 暂存区和HEAD
git diff HEAD 工作区和HEAD

git cat-file 查看对象
git cat-tree
git ls-files
git ls-tree
git write-tree
git rev-parse 显示引用对应的分支

git cat-file -p
git rev-parse

master 代表分支master中最新的提交
HEAD 代表版本库中最近的一次提交
HEAD^2
HEAD~6
aa1234^{tree}
aa1234:path/to/file 提交对应的文件对象
:path/to/file 暂存区

SHA1 哈希值 是通过 “对象名（commit/blob/tree）+字节数+空字符+内容（cat-file）”--> 40位的散列值/哈希值 --> 为什么不按照顺序来呢？

分支游标master

git reflog show master 显示master指针
git reflog -1 默认是HEAD指针

checkout -- 中的 -- 是为了避免路径和引用的重名

分离头指针-->HEAD 头指针指向的是一个具体的提交ID，而不是一个引用（分支）

git checkout branch
git checkout -- filename 用暂存区的文件来覆盖本地的，取消自上次git add filename依赖的本地修改
git checkout branch -- filename 维持HEAD指针不变，用branch所指向的提交中的filename替换暂存区和工作区中的文件

重置 和 检出 --> 暂存区 & 工作区

git reset --soft HEAD^ 取消前面的一次提交

git clean 可以删除本地多余的文件和目录

WIP work in progess

git stash 是通过一个脚本来实现的
先commit ，然后保存commit，即添加一个stash引用，然后通过 git reset --hard 重置working directory和index
日志、引用的日志

git tag 其实也是一个引用，通过记录提交ID（或创建Tag对象）来为当前版本库的状态进行“留影”

git add -u 快速标记删除，将本地文件中的变更（修改，删除）全部记录到暂存区中（为了解决本地文件删除，而暂存区文件没删除的现象）

git mv 相当于 git del +git add
git add -A 相当于对修改的文件执行git add, 本地删除的文件执行 git rm ,  对新增的文件执行git add

文件归档

git archive -o latest.zip HEAD
git archive -o pratial.tar HEAD src doc
git archive --format=tar --prefix=1.0/ v1.0 | gzip > foo-1.0.tar.gz

tar -czf hello.tar.gz root
tar -zcf hello.tar.gz
git add -i 交互式添加文件

.gitignore语法
*.a
!lib.a
/TODO #只忽略此目录下的TODO语法，子目录的TODO文件不忽略
build/   # 忽略所有build/目录下的文件
doc/*.txt

.git/info/exclude 设置只对本地有效的独享式文件忽略


git statsh 是通过一个脚本程序来实现的，其中包含git reset -- hard HEAD 过程
git diff 可真对各类引用进行对比

git rev-parse refs/tags/old_practices
git describe

一个显示版本好的Hello World, 将git describe 的输出作为软件版本号
目录文件结构
```
../src
├── Makefile
├── main.c
└── version.h.in
```
- main.c 内容
``` c
#include "version.h"
#include <stdio.h>

int main(){
    printf("Hello,world.\n");
    printf("version: %s.\n", _VERSION);
    return 0;
}

```
- version.h.in 内容
``` c
#ifndef HELLO_WORLD_VERSION_H
#define HELLO_WORLD_VERSION_H

#define _VERSION "<version>"

#endif
```

- Makefile
``` Makefile
OBJECTS = main.o
TARGET = helloworld

all: ${TARGET}

${TARGET}: ${OBJECTS}
	${CC} -o $@ $^

main.o: main.c version.h

version.h: new_header

new_header:
	@sed -e "s/<version>/$$(git describe --tags)/g" \
		< version.h.in > version.h.tmp
	@if diff -q version.h.tmp version.h >/dev/null 2>&1; \
	then \
		rm version.h.tmp; \
	else \
		echo "version.h.in => version.h"; \
		mv version.h.tmp version.h; \
	fi

clean:
	rm -rf ${OBJECTS} version.h

.PHONY: all clean
```


克隆生成裸版库 `git clone --bare /path/to/demo /path/to/repose/demo.git`
创建生成裸版库 `git init --bare /path/demo-init.git`
git ls-remote

git rev-parse 版本表示法
git rev-list 版本范围表示法

git log --stat --oneline 只需显示修改了的文件名
git diff 可针对二进制进行比较，同时也可以逐词比较(`--word-diff`)

文件溯源 `git blame capture.sh`
二分查找 `git bisect`, 通过标记版本的好坏
`git bisect --> git bisect good ; git bisect good G --> git bisect bad .......`

`git show b80d5a4:agent/sysinfo.py > sysinfo_old.py` 检出文件历史版本到新的文件
`git checkout b80d5a4 -- ./agent.py`
`git checkout b80d5a4 ` 整个工作去切换到历史版本
`git ls-tree b80d5a4 ` 查看历史提交的目录树

悔棋 `git reset` `git rebase` `git merge`
`git rebase --onto <newbase> <since> <till>`
`git rebase -i HEAD^^`
`git rebase --onto 8f7f94b A master` 将master分支里程碑之后的提交全部迁移到根提交8f7f94b上

再多人协作的过程中，可进行反转提交
git show HEAD
git revert HEAD 在不改变原提交的前提下，撤销对其的修改

git 以SHA1 哈希值作为目录名和文件名保存的对象又一个术语，称之为松散对象，而松散对象打包后会提高效率
git管家: `git gc`
